// Code generated by mockery v2.41.0. DO NOT EDIT.

package mocks

import (
	context "context"

	domain "github.com/leighmacdonald/gbans/internal/domain"
	mock "github.com/stretchr/testify/mock"

	net "net"

	steamid "github.com/leighmacdonald/steamid/v3/steamid"
)

// MockStateUsecase is an autogenerated mock type for the StateUsecase type
type MockStateUsecase struct {
	mock.Mock
}

type MockStateUsecase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStateUsecase) EXPECT() *MockStateUsecase_Expecter {
	return &MockStateUsecase_Expecter{mock: &_m.Mock}
}

// Broadcast provides a mock function with given fields: ctx, serverIDs, cmd
func (_m *MockStateUsecase) Broadcast(ctx context.Context, serverIDs []int, cmd string) map[int]string {
	ret := _m.Called(ctx, serverIDs, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Broadcast")
	}

	var r0 map[int]string
	if rf, ok := ret.Get(0).(func(context.Context, []int, string) map[int]string); ok {
		r0 = rf(ctx, serverIDs, cmd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int]string)
		}
	}

	return r0
}

// MockStateUsecase_Broadcast_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Broadcast'
type MockStateUsecase_Broadcast_Call struct {
	*mock.Call
}

// Broadcast is a helper method to define mock.On call
//   - ctx context.Context
//   - serverIDs []int
//   - cmd string
func (_e *MockStateUsecase_Expecter) Broadcast(ctx interface{}, serverIDs interface{}, cmd interface{}) *MockStateUsecase_Broadcast_Call {
	return &MockStateUsecase_Broadcast_Call{Call: _e.mock.On("Broadcast", ctx, serverIDs, cmd)}
}

func (_c *MockStateUsecase_Broadcast_Call) Run(run func(ctx context.Context, serverIDs []int, cmd string)) *MockStateUsecase_Broadcast_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int), args[2].(string))
	})
	return _c
}

func (_c *MockStateUsecase_Broadcast_Call) Return(_a0 map[int]string) *MockStateUsecase_Broadcast_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Broadcast_Call) RunAndReturn(run func(context.Context, []int, string) map[int]string) *MockStateUsecase_Broadcast_Call {
	_c.Call.Return(run)
	return _c
}

// ByName provides a mock function with given fields: name, wildcardOk
func (_m *MockStateUsecase) ByName(name string, wildcardOk bool) []domain.ServerState {
	ret := _m.Called(name, wildcardOk)

	if len(ret) == 0 {
		panic("no return value specified for ByName")
	}

	var r0 []domain.ServerState
	if rf, ok := ret.Get(0).(func(string, bool) []domain.ServerState); ok {
		r0 = rf(name, wildcardOk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.ServerState)
		}
	}

	return r0
}

// MockStateUsecase_ByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByName'
type MockStateUsecase_ByName_Call struct {
	*mock.Call
}

// ByName is a helper method to define mock.On call
//   - name string
//   - wildcardOk bool
func (_e *MockStateUsecase_Expecter) ByName(name interface{}, wildcardOk interface{}) *MockStateUsecase_ByName_Call {
	return &MockStateUsecase_ByName_Call{Call: _e.mock.On("ByName", name, wildcardOk)}
}

func (_c *MockStateUsecase_ByName_Call) Run(run func(name string, wildcardOk bool)) *MockStateUsecase_ByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *MockStateUsecase_ByName_Call) Return(_a0 []domain.ServerState) *MockStateUsecase_ByName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_ByName_Call) RunAndReturn(run func(string, bool) []domain.ServerState) *MockStateUsecase_ByName_Call {
	_c.Call.Return(run)
	return _c
}

// ByServerID provides a mock function with given fields: serverID
func (_m *MockStateUsecase) ByServerID(serverID int) (domain.ServerState, bool) {
	ret := _m.Called(serverID)

	if len(ret) == 0 {
		panic("no return value specified for ByServerID")
	}

	var r0 domain.ServerState
	var r1 bool
	if rf, ok := ret.Get(0).(func(int) (domain.ServerState, bool)); ok {
		return rf(serverID)
	}
	if rf, ok := ret.Get(0).(func(int) domain.ServerState); ok {
		r0 = rf(serverID)
	} else {
		r0 = ret.Get(0).(domain.ServerState)
	}

	if rf, ok := ret.Get(1).(func(int) bool); ok {
		r1 = rf(serverID)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockStateUsecase_ByServerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByServerID'
type MockStateUsecase_ByServerID_Call struct {
	*mock.Call
}

// ByServerID is a helper method to define mock.On call
//   - serverID int
func (_e *MockStateUsecase_Expecter) ByServerID(serverID interface{}) *MockStateUsecase_ByServerID_Call {
	return &MockStateUsecase_ByServerID_Call{Call: _e.mock.On("ByServerID", serverID)}
}

func (_c *MockStateUsecase_ByServerID_Call) Run(run func(serverID int)) *MockStateUsecase_ByServerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *MockStateUsecase_ByServerID_Call) Return(_a0 domain.ServerState, _a1 bool) *MockStateUsecase_ByServerID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStateUsecase_ByServerID_Call) RunAndReturn(run func(int) (domain.ServerState, bool)) *MockStateUsecase_ByServerID_Call {
	_c.Call.Return(run)
	return _c
}

// CSay provides a mock function with given fields: ctx, serverID, message
func (_m *MockStateUsecase) CSay(ctx context.Context, serverID int, message string) error {
	ret := _m.Called(ctx, serverID, message)

	if len(ret) == 0 {
		panic("no return value specified for CSay")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string) error); ok {
		r0 = rf(ctx, serverID, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_CSay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CSay'
type MockStateUsecase_CSay_Call struct {
	*mock.Call
}

// CSay is a helper method to define mock.On call
//   - ctx context.Context
//   - serverID int
//   - message string
func (_e *MockStateUsecase_Expecter) CSay(ctx interface{}, serverID interface{}, message interface{}) *MockStateUsecase_CSay_Call {
	return &MockStateUsecase_CSay_Call{Call: _e.mock.On("CSay", ctx, serverID, message)}
}

func (_c *MockStateUsecase_CSay_Call) Run(run func(ctx context.Context, serverID int, message string)) *MockStateUsecase_CSay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(string))
	})
	return _c
}

func (_c *MockStateUsecase_CSay_Call) Return(_a0 error) *MockStateUsecase_CSay_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_CSay_Call) RunAndReturn(run func(context.Context, int, string) error) *MockStateUsecase_CSay_Call {
	_c.Call.Return(run)
	return _c
}

// Current provides a mock function with given fields:
func (_m *MockStateUsecase) Current() []domain.ServerState {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Current")
	}

	var r0 []domain.ServerState
	if rf, ok := ret.Get(0).(func() []domain.ServerState); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.ServerState)
		}
	}

	return r0
}

// MockStateUsecase_Current_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Current'
type MockStateUsecase_Current_Call struct {
	*mock.Call
}

// Current is a helper method to define mock.On call
func (_e *MockStateUsecase_Expecter) Current() *MockStateUsecase_Current_Call {
	return &MockStateUsecase_Current_Call{Call: _e.mock.On("Current")}
}

func (_c *MockStateUsecase_Current_Call) Run(run func()) *MockStateUsecase_Current_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStateUsecase_Current_Call) Return(_a0 []domain.ServerState) *MockStateUsecase_Current_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Current_Call) RunAndReturn(run func() []domain.ServerState) *MockStateUsecase_Current_Call {
	_c.Call.Return(run)
	return _c
}

// ExecRaw provides a mock function with given fields: ctx, addr, password, cmd
func (_m *MockStateUsecase) ExecRaw(ctx context.Context, addr string, password string, cmd string) (string, error) {
	ret := _m.Called(ctx, addr, password, cmd)

	if len(ret) == 0 {
		panic("no return value specified for ExecRaw")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (string, error)); ok {
		return rf(ctx, addr, password, cmd)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) string); ok {
		r0 = rf(ctx, addr, password, cmd)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, addr, password, cmd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStateUsecase_ExecRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecRaw'
type MockStateUsecase_ExecRaw_Call struct {
	*mock.Call
}

// ExecRaw is a helper method to define mock.On call
//   - ctx context.Context
//   - addr string
//   - password string
//   - cmd string
func (_e *MockStateUsecase_Expecter) ExecRaw(ctx interface{}, addr interface{}, password interface{}, cmd interface{}) *MockStateUsecase_ExecRaw_Call {
	return &MockStateUsecase_ExecRaw_Call{Call: _e.mock.On("ExecRaw", ctx, addr, password, cmd)}
}

func (_c *MockStateUsecase_ExecRaw_Call) Run(run func(ctx context.Context, addr string, password string, cmd string)) *MockStateUsecase_ExecRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockStateUsecase_ExecRaw_Call) Return(_a0 string, _a1 error) *MockStateUsecase_ExecRaw_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStateUsecase_ExecRaw_Call) RunAndReturn(run func(context.Context, string, string, string) (string, error)) *MockStateUsecase_ExecRaw_Call {
	_c.Call.Return(run)
	return _c
}

// ExecServer provides a mock function with given fields: ctx, serverID, cmd
func (_m *MockStateUsecase) ExecServer(ctx context.Context, serverID int, cmd string) (string, error) {
	ret := _m.Called(ctx, serverID, cmd)

	if len(ret) == 0 {
		panic("no return value specified for ExecServer")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string) (string, error)); ok {
		return rf(ctx, serverID, cmd)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string) string); ok {
		r0 = rf(ctx, serverID, cmd)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string) error); ok {
		r1 = rf(ctx, serverID, cmd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStateUsecase_ExecServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecServer'
type MockStateUsecase_ExecServer_Call struct {
	*mock.Call
}

// ExecServer is a helper method to define mock.On call
//   - ctx context.Context
//   - serverID int
//   - cmd string
func (_e *MockStateUsecase_Expecter) ExecServer(ctx interface{}, serverID interface{}, cmd interface{}) *MockStateUsecase_ExecServer_Call {
	return &MockStateUsecase_ExecServer_Call{Call: _e.mock.On("ExecServer", ctx, serverID, cmd)}
}

func (_c *MockStateUsecase_ExecServer_Call) Run(run func(ctx context.Context, serverID int, cmd string)) *MockStateUsecase_ExecServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(string))
	})
	return _c
}

func (_c *MockStateUsecase_ExecServer_Call) Return(_a0 string, _a1 error) *MockStateUsecase_ExecServer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStateUsecase_ExecServer_Call) RunAndReturn(run func(context.Context, int, string) (string, error)) *MockStateUsecase_ExecServer_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: name, steamID, addr, cidr
func (_m *MockStateUsecase) Find(name string, steamID steamid.SID64, addr net.IP, cidr *net.IPNet) []domain.PlayerServerInfo {
	ret := _m.Called(name, steamID, addr, cidr)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 []domain.PlayerServerInfo
	if rf, ok := ret.Get(0).(func(string, steamid.SID64, net.IP, *net.IPNet) []domain.PlayerServerInfo); ok {
		r0 = rf(name, steamID, addr, cidr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PlayerServerInfo)
		}
	}

	return r0
}

// MockStateUsecase_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type MockStateUsecase_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - name string
//   - steamID steamid.SID64
//   - addr net.IP
//   - cidr *net.IPNet
func (_e *MockStateUsecase_Expecter) Find(name interface{}, steamID interface{}, addr interface{}, cidr interface{}) *MockStateUsecase_Find_Call {
	return &MockStateUsecase_Find_Call{Call: _e.mock.On("Find", name, steamID, addr, cidr)}
}

func (_c *MockStateUsecase_Find_Call) Run(run func(name string, steamID steamid.SID64, addr net.IP, cidr *net.IPNet)) *MockStateUsecase_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(steamid.SID64), args[2].(net.IP), args[3].(*net.IPNet))
	})
	return _c
}

func (_c *MockStateUsecase_Find_Call) Return(_a0 []domain.PlayerServerInfo) *MockStateUsecase_Find_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Find_Call) RunAndReturn(run func(string, steamid.SID64, net.IP, *net.IPNet) []domain.PlayerServerInfo) *MockStateUsecase_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindByCIDR provides a mock function with given fields: cidr
func (_m *MockStateUsecase) FindByCIDR(cidr *net.IPNet) []domain.PlayerServerInfo {
	ret := _m.Called(cidr)

	if len(ret) == 0 {
		panic("no return value specified for FindByCIDR")
	}

	var r0 []domain.PlayerServerInfo
	if rf, ok := ret.Get(0).(func(*net.IPNet) []domain.PlayerServerInfo); ok {
		r0 = rf(cidr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PlayerServerInfo)
		}
	}

	return r0
}

// MockStateUsecase_FindByCIDR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByCIDR'
type MockStateUsecase_FindByCIDR_Call struct {
	*mock.Call
}

// FindByCIDR is a helper method to define mock.On call
//   - cidr *net.IPNet
func (_e *MockStateUsecase_Expecter) FindByCIDR(cidr interface{}) *MockStateUsecase_FindByCIDR_Call {
	return &MockStateUsecase_FindByCIDR_Call{Call: _e.mock.On("FindByCIDR", cidr)}
}

func (_c *MockStateUsecase_FindByCIDR_Call) Run(run func(cidr *net.IPNet)) *MockStateUsecase_FindByCIDR_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*net.IPNet))
	})
	return _c
}

func (_c *MockStateUsecase_FindByCIDR_Call) Return(_a0 []domain.PlayerServerInfo) *MockStateUsecase_FindByCIDR_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_FindByCIDR_Call) RunAndReturn(run func(*net.IPNet) []domain.PlayerServerInfo) *MockStateUsecase_FindByCIDR_Call {
	_c.Call.Return(run)
	return _c
}

// FindByIP provides a mock function with given fields: addr
func (_m *MockStateUsecase) FindByIP(addr net.IP) []domain.PlayerServerInfo {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		panic("no return value specified for FindByIP")
	}

	var r0 []domain.PlayerServerInfo
	if rf, ok := ret.Get(0).(func(net.IP) []domain.PlayerServerInfo); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PlayerServerInfo)
		}
	}

	return r0
}

// MockStateUsecase_FindByIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByIP'
type MockStateUsecase_FindByIP_Call struct {
	*mock.Call
}

// FindByIP is a helper method to define mock.On call
//   - addr net.IP
func (_e *MockStateUsecase_Expecter) FindByIP(addr interface{}) *MockStateUsecase_FindByIP_Call {
	return &MockStateUsecase_FindByIP_Call{Call: _e.mock.On("FindByIP", addr)}
}

func (_c *MockStateUsecase_FindByIP_Call) Run(run func(addr net.IP)) *MockStateUsecase_FindByIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(net.IP))
	})
	return _c
}

func (_c *MockStateUsecase_FindByIP_Call) Return(_a0 []domain.PlayerServerInfo) *MockStateUsecase_FindByIP_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_FindByIP_Call) RunAndReturn(run func(net.IP) []domain.PlayerServerInfo) *MockStateUsecase_FindByIP_Call {
	_c.Call.Return(run)
	return _c
}

// FindByName provides a mock function with given fields: name
func (_m *MockStateUsecase) FindByName(name string) []domain.PlayerServerInfo {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for FindByName")
	}

	var r0 []domain.PlayerServerInfo
	if rf, ok := ret.Get(0).(func(string) []domain.PlayerServerInfo); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PlayerServerInfo)
		}
	}

	return r0
}

// MockStateUsecase_FindByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByName'
type MockStateUsecase_FindByName_Call struct {
	*mock.Call
}

// FindByName is a helper method to define mock.On call
//   - name string
func (_e *MockStateUsecase_Expecter) FindByName(name interface{}) *MockStateUsecase_FindByName_Call {
	return &MockStateUsecase_FindByName_Call{Call: _e.mock.On("FindByName", name)}
}

func (_c *MockStateUsecase_FindByName_Call) Run(run func(name string)) *MockStateUsecase_FindByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStateUsecase_FindByName_Call) Return(_a0 []domain.PlayerServerInfo) *MockStateUsecase_FindByName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_FindByName_Call) RunAndReturn(run func(string) []domain.PlayerServerInfo) *MockStateUsecase_FindByName_Call {
	_c.Call.Return(run)
	return _c
}

// FindBySteamID provides a mock function with given fields: steamID
func (_m *MockStateUsecase) FindBySteamID(steamID steamid.SID64) []domain.PlayerServerInfo {
	ret := _m.Called(steamID)

	if len(ret) == 0 {
		panic("no return value specified for FindBySteamID")
	}

	var r0 []domain.PlayerServerInfo
	if rf, ok := ret.Get(0).(func(steamid.SID64) []domain.PlayerServerInfo); ok {
		r0 = rf(steamID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PlayerServerInfo)
		}
	}

	return r0
}

// MockStateUsecase_FindBySteamID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBySteamID'
type MockStateUsecase_FindBySteamID_Call struct {
	*mock.Call
}

// FindBySteamID is a helper method to define mock.On call
//   - steamID steamid.SID64
func (_e *MockStateUsecase_Expecter) FindBySteamID(steamID interface{}) *MockStateUsecase_FindBySteamID_Call {
	return &MockStateUsecase_FindBySteamID_Call{Call: _e.mock.On("FindBySteamID", steamID)}
}

func (_c *MockStateUsecase_FindBySteamID_Call) Run(run func(steamID steamid.SID64)) *MockStateUsecase_FindBySteamID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(steamid.SID64))
	})
	return _c
}

func (_c *MockStateUsecase_FindBySteamID_Call) Return(_a0 []domain.PlayerServerInfo) *MockStateUsecase_FindBySteamID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_FindBySteamID_Call) RunAndReturn(run func(steamid.SID64) []domain.PlayerServerInfo) *MockStateUsecase_FindBySteamID_Call {
	_c.Call.Return(run)
	return _c
}

// Kick provides a mock function with given fields: ctx, target, reason
func (_m *MockStateUsecase) Kick(ctx context.Context, target steamid.SID64, reason domain.Reason) error {
	ret := _m.Called(ctx, target, reason)

	if len(ret) == 0 {
		panic("no return value specified for Kick")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, steamid.SID64, domain.Reason) error); ok {
		r0 = rf(ctx, target, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_Kick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Kick'
type MockStateUsecase_Kick_Call struct {
	*mock.Call
}

// Kick is a helper method to define mock.On call
//   - ctx context.Context
//   - target steamid.SID64
//   - reason domain.Reason
func (_e *MockStateUsecase_Expecter) Kick(ctx interface{}, target interface{}, reason interface{}) *MockStateUsecase_Kick_Call {
	return &MockStateUsecase_Kick_Call{Call: _e.mock.On("Kick", ctx, target, reason)}
}

func (_c *MockStateUsecase_Kick_Call) Run(run func(ctx context.Context, target steamid.SID64, reason domain.Reason)) *MockStateUsecase_Kick_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(steamid.SID64), args[2].(domain.Reason))
	})
	return _c
}

func (_c *MockStateUsecase_Kick_Call) Return(_a0 error) *MockStateUsecase_Kick_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Kick_Call) RunAndReturn(run func(context.Context, steamid.SID64, domain.Reason) error) *MockStateUsecase_Kick_Call {
	_c.Call.Return(run)
	return _c
}

// LogAddressAdd provides a mock function with given fields: ctx, logAddress
func (_m *MockStateUsecase) LogAddressAdd(ctx context.Context, logAddress string) {
	_m.Called(ctx, logAddress)
}

// MockStateUsecase_LogAddressAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogAddressAdd'
type MockStateUsecase_LogAddressAdd_Call struct {
	*mock.Call
}

// LogAddressAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - logAddress string
func (_e *MockStateUsecase_Expecter) LogAddressAdd(ctx interface{}, logAddress interface{}) *MockStateUsecase_LogAddressAdd_Call {
	return &MockStateUsecase_LogAddressAdd_Call{Call: _e.mock.On("LogAddressAdd", ctx, logAddress)}
}

func (_c *MockStateUsecase_LogAddressAdd_Call) Run(run func(ctx context.Context, logAddress string)) *MockStateUsecase_LogAddressAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStateUsecase_LogAddressAdd_Call) Return() *MockStateUsecase_LogAddressAdd_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockStateUsecase_LogAddressAdd_Call) RunAndReturn(run func(context.Context, string)) *MockStateUsecase_LogAddressAdd_Call {
	_c.Call.Return(run)
	return _c
}

// OnFindExec provides a mock function with given fields: ctx, name, steamID, ip, cidr, onFoundCmd
func (_m *MockStateUsecase) OnFindExec(ctx context.Context, name string, steamID steamid.SID64, ip net.IP, cidr *net.IPNet, onFoundCmd func(domain.PlayerServerInfo) string) error {
	ret := _m.Called(ctx, name, steamID, ip, cidr, onFoundCmd)

	if len(ret) == 0 {
		panic("no return value specified for OnFindExec")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, steamid.SID64, net.IP, *net.IPNet, func(domain.PlayerServerInfo) string) error); ok {
		r0 = rf(ctx, name, steamID, ip, cidr, onFoundCmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_OnFindExec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnFindExec'
type MockStateUsecase_OnFindExec_Call struct {
	*mock.Call
}

// OnFindExec is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - steamID steamid.SID64
//   - ip net.IP
//   - cidr *net.IPNet
//   - onFoundCmd func(domain.PlayerServerInfo) string
func (_e *MockStateUsecase_Expecter) OnFindExec(ctx interface{}, name interface{}, steamID interface{}, ip interface{}, cidr interface{}, onFoundCmd interface{}) *MockStateUsecase_OnFindExec_Call {
	return &MockStateUsecase_OnFindExec_Call{Call: _e.mock.On("OnFindExec", ctx, name, steamID, ip, cidr, onFoundCmd)}
}

func (_c *MockStateUsecase_OnFindExec_Call) Run(run func(ctx context.Context, name string, steamID steamid.SID64, ip net.IP, cidr *net.IPNet, onFoundCmd func(domain.PlayerServerInfo) string)) *MockStateUsecase_OnFindExec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(steamid.SID64), args[3].(net.IP), args[4].(*net.IPNet), args[5].(func(domain.PlayerServerInfo) string))
	})
	return _c
}

func (_c *MockStateUsecase_OnFindExec_Call) Return(_a0 error) *MockStateUsecase_OnFindExec_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_OnFindExec_Call) RunAndReturn(run func(context.Context, string, steamid.SID64, net.IP, *net.IPNet, func(domain.PlayerServerInfo) string) error) *MockStateUsecase_OnFindExec_Call {
	_c.Call.Return(run)
	return _c
}

// PSay provides a mock function with given fields: ctx, target, message
func (_m *MockStateUsecase) PSay(ctx context.Context, target steamid.SID64, message string) error {
	ret := _m.Called(ctx, target, message)

	if len(ret) == 0 {
		panic("no return value specified for PSay")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, steamid.SID64, string) error); ok {
		r0 = rf(ctx, target, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_PSay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PSay'
type MockStateUsecase_PSay_Call struct {
	*mock.Call
}

// PSay is a helper method to define mock.On call
//   - ctx context.Context
//   - target steamid.SID64
//   - message string
func (_e *MockStateUsecase_Expecter) PSay(ctx interface{}, target interface{}, message interface{}) *MockStateUsecase_PSay_Call {
	return &MockStateUsecase_PSay_Call{Call: _e.mock.On("PSay", ctx, target, message)}
}

func (_c *MockStateUsecase_PSay_Call) Run(run func(ctx context.Context, target steamid.SID64, message string)) *MockStateUsecase_PSay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(steamid.SID64), args[2].(string))
	})
	return _c
}

func (_c *MockStateUsecase_PSay_Call) Return(_a0 error) *MockStateUsecase_PSay_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_PSay_Call) RunAndReturn(run func(context.Context, steamid.SID64, string) error) *MockStateUsecase_PSay_Call {
	_c.Call.Return(run)
	return _c
}

// Say provides a mock function with given fields: ctx, serverID, message
func (_m *MockStateUsecase) Say(ctx context.Context, serverID int, message string) error {
	ret := _m.Called(ctx, serverID, message)

	if len(ret) == 0 {
		panic("no return value specified for Say")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string) error); ok {
		r0 = rf(ctx, serverID, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_Say_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Say'
type MockStateUsecase_Say_Call struct {
	*mock.Call
}

// Say is a helper method to define mock.On call
//   - ctx context.Context
//   - serverID int
//   - message string
func (_e *MockStateUsecase_Expecter) Say(ctx interface{}, serverID interface{}, message interface{}) *MockStateUsecase_Say_Call {
	return &MockStateUsecase_Say_Call{Call: _e.mock.On("Say", ctx, serverID, message)}
}

func (_c *MockStateUsecase_Say_Call) Run(run func(ctx context.Context, serverID int, message string)) *MockStateUsecase_Say_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(string))
	})
	return _c
}

func (_c *MockStateUsecase_Say_Call) Return(_a0 error) *MockStateUsecase_Say_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Say_Call) RunAndReturn(run func(context.Context, int, string) error) *MockStateUsecase_Say_Call {
	_c.Call.Return(run)
	return _c
}

// ServerIDsByName provides a mock function with given fields: name, wildcardOk
func (_m *MockStateUsecase) ServerIDsByName(name string, wildcardOk bool) []int {
	ret := _m.Called(name, wildcardOk)

	if len(ret) == 0 {
		panic("no return value specified for ServerIDsByName")
	}

	var r0 []int
	if rf, ok := ret.Get(0).(func(string, bool) []int); ok {
		r0 = rf(name, wildcardOk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	return r0
}

// MockStateUsecase_ServerIDsByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerIDsByName'
type MockStateUsecase_ServerIDsByName_Call struct {
	*mock.Call
}

// ServerIDsByName is a helper method to define mock.On call
//   - name string
//   - wildcardOk bool
func (_e *MockStateUsecase_Expecter) ServerIDsByName(name interface{}, wildcardOk interface{}) *MockStateUsecase_ServerIDsByName_Call {
	return &MockStateUsecase_ServerIDsByName_Call{Call: _e.mock.On("ServerIDsByName", name, wildcardOk)}
}

func (_c *MockStateUsecase_ServerIDsByName_Call) Run(run func(name string, wildcardOk bool)) *MockStateUsecase_ServerIDsByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *MockStateUsecase_ServerIDsByName_Call) Return(_a0 []int) *MockStateUsecase_ServerIDsByName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_ServerIDsByName_Call) RunAndReturn(run func(string, bool) []int) *MockStateUsecase_ServerIDsByName_Call {
	_c.Call.Return(run)
	return _c
}

// Silence provides a mock function with given fields: ctx, target, reason
func (_m *MockStateUsecase) Silence(ctx context.Context, target steamid.SID64, reason domain.Reason) error {
	ret := _m.Called(ctx, target, reason)

	if len(ret) == 0 {
		panic("no return value specified for Silence")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, steamid.SID64, domain.Reason) error); ok {
		r0 = rf(ctx, target, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_Silence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Silence'
type MockStateUsecase_Silence_Call struct {
	*mock.Call
}

// Silence is a helper method to define mock.On call
//   - ctx context.Context
//   - target steamid.SID64
//   - reason domain.Reason
func (_e *MockStateUsecase_Expecter) Silence(ctx interface{}, target interface{}, reason interface{}) *MockStateUsecase_Silence_Call {
	return &MockStateUsecase_Silence_Call{Call: _e.mock.On("Silence", ctx, target, reason)}
}

func (_c *MockStateUsecase_Silence_Call) Run(run func(ctx context.Context, target steamid.SID64, reason domain.Reason)) *MockStateUsecase_Silence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(steamid.SID64), args[2].(domain.Reason))
	})
	return _c
}

func (_c *MockStateUsecase_Silence_Call) Return(_a0 error) *MockStateUsecase_Silence_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Silence_Call) RunAndReturn(run func(context.Context, steamid.SID64, domain.Reason) error) *MockStateUsecase_Silence_Call {
	_c.Call.Return(run)
	return _c
}

// SortRegion provides a mock function with given fields:
func (_m *MockStateUsecase) SortRegion() map[string][]domain.ServerState {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SortRegion")
	}

	var r0 map[string][]domain.ServerState
	if rf, ok := ret.Get(0).(func() map[string][]domain.ServerState); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]domain.ServerState)
		}
	}

	return r0
}

// MockStateUsecase_SortRegion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortRegion'
type MockStateUsecase_SortRegion_Call struct {
	*mock.Call
}

// SortRegion is a helper method to define mock.On call
func (_e *MockStateUsecase_Expecter) SortRegion() *MockStateUsecase_SortRegion_Call {
	return &MockStateUsecase_SortRegion_Call{Call: _e.mock.On("SortRegion")}
}

func (_c *MockStateUsecase_SortRegion_Call) Run(run func()) *MockStateUsecase_SortRegion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStateUsecase_SortRegion_Call) Return(_a0 map[string][]domain.ServerState) *MockStateUsecase_SortRegion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_SortRegion_Call) RunAndReturn(run func() map[string][]domain.ServerState) *MockStateUsecase_SortRegion_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function with given fields: ctx
func (_m *MockStateUsecase) Start(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MockStateUsecase_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStateUsecase_Expecter) Start(ctx interface{}) *MockStateUsecase_Start_Call {
	return &MockStateUsecase_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *MockStateUsecase_Start_Call) Run(run func(ctx context.Context)) *MockStateUsecase_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStateUsecase_Start_Call) Return(_a0 error) *MockStateUsecase_Start_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Start_Call) RunAndReturn(run func(context.Context) error) *MockStateUsecase_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: serverID, update
func (_m *MockStateUsecase) Update(serverID int, update domain.PartialStateUpdate) error {
	ret := _m.Called(serverID, update)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, domain.PartialStateUpdate) error); ok {
		r0 = rf(serverID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStateUsecase_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockStateUsecase_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - serverID int
//   - update domain.PartialStateUpdate
func (_e *MockStateUsecase_Expecter) Update(serverID interface{}, update interface{}) *MockStateUsecase_Update_Call {
	return &MockStateUsecase_Update_Call{Call: _e.mock.On("Update", serverID, update)}
}

func (_c *MockStateUsecase_Update_Call) Run(run func(serverID int, update domain.PartialStateUpdate)) *MockStateUsecase_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(domain.PartialStateUpdate))
	})
	return _c
}

func (_c *MockStateUsecase_Update_Call) Return(_a0 error) *MockStateUsecase_Update_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStateUsecase_Update_Call) RunAndReturn(run func(int, domain.PartialStateUpdate) error) *MockStateUsecase_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStateUsecase creates a new instance of MockStateUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStateUsecase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStateUsecase {
	mock := &MockStateUsecase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
