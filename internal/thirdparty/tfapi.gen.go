// Package thirdparty provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package thirdparty

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for LeagueResponseFormat.
const (
	LeagueResponseFormatBball          LeagueResponseFormat = "bball"
	LeagueResponseFormatHighlander     LeagueResponseFormat = "highlander"
	LeagueResponseFormatN1v1           LeagueResponseFormat = "1v1"
	LeagueResponseFormatN4v4           LeagueResponseFormat = "4v4"
	LeagueResponseFormatN6v6           LeagueResponseFormat = "6v6"
	LeagueResponseFormatNr6v6          LeagueResponseFormat = "nr6v6"
	LeagueResponseFormatOther          LeagueResponseFormat = "other"
	LeagueResponseFormatPasstime       LeagueResponseFormat = "passtime"
	LeagueResponseFormatProlander      LeagueResponseFormat = "prolander"
	LeagueResponseFormatReadysteadypan LeagueResponseFormat = "readysteadypan"
	LeagueResponseFormatUltiduo        LeagueResponseFormat = "ultiduo"
)

// Defines values for LeagueResponseType.
const (
	LeagueResponseTypeCup    LeagueResponseType = "cup"
	LeagueResponseTypeOther  LeagueResponseType = "other"
	LeagueResponseTypeSeason LeagueResponseType = "season"
)

// Defines values for LogsTFMatchVersion.
const (
	LogsTFMatchVersionN1 LogsTFMatchVersion = 1
	LogsTFMatchVersionN2 LogsTFMatchVersion = 2
	LogsTFMatchVersionN3 LogsTFMatchVersion = 3
)

// Defines values for LogsTFMatchInfoVersion.
const (
	LogsTFMatchInfoVersionN1 LogsTFMatchInfoVersion = 1
	LogsTFMatchInfoVersionN2 LogsTFMatchInfoVersion = 2
	LogsTFMatchInfoVersionN3 LogsTFMatchInfoVersion = 3
)

// Defines values for MetaProfileCommunityVisibilityState.
const (
	MetaProfileCommunityVisibilityStateN1 MetaProfileCommunityVisibilityState = 1
	MetaProfileCommunityVisibilityStateN2 MetaProfileCommunityVisibilityState = 2
	MetaProfileCommunityVisibilityStateN3 MetaProfileCommunityVisibilityState = 3
)

// Defines values for MetaProfileProfileState.
const (
	MetaProfileProfileStateN0 MetaProfileProfileState = 0
	MetaProfileProfileStateN1 MetaProfileProfileState = 1
)

// Defines values for PlayerTeamHistoryResponseType.
const (
	PlayerTeamHistoryResponseTypeCup    PlayerTeamHistoryResponseType = "cup"
	PlayerTeamHistoryResponseTypeOther  PlayerTeamHistoryResponseType = "other"
	PlayerTeamHistoryResponseTypeSeason PlayerTeamHistoryResponseType = "season"
)

// Defines values for LeaguesCompetitionsParamsLeague.
const (
	LeaguesCompetitionsParamsLeagueEtf2l      LeaguesCompetitionsParamsLeague = "etf2l"
	LeaguesCompetitionsParamsLeagueMgetf      LeaguesCompetitionsParamsLeague = "mgetf"
	LeaguesCompetitionsParamsLeagueOzfortress LeaguesCompetitionsParamsLeague = "ozfortress"
	LeaguesCompetitionsParamsLeagueRgl        LeaguesCompetitionsParamsLeague = "rgl"
	LeaguesCompetitionsParamsLeagueUgc        LeaguesCompetitionsParamsLeague = "ugc"
)

// Defines values for LeaguesCompetitionsParamsFormat.
const (
	LeaguesCompetitionsParamsFormatBball          LeaguesCompetitionsParamsFormat = "bball"
	LeaguesCompetitionsParamsFormatHighlander     LeaguesCompetitionsParamsFormat = "highlander"
	LeaguesCompetitionsParamsFormatN1v1           LeaguesCompetitionsParamsFormat = "1v1"
	LeaguesCompetitionsParamsFormatN4v4           LeaguesCompetitionsParamsFormat = "4v4"
	LeaguesCompetitionsParamsFormatN6v6           LeaguesCompetitionsParamsFormat = "6v6"
	LeaguesCompetitionsParamsFormatNr6v6          LeaguesCompetitionsParamsFormat = "nr6v6"
	LeaguesCompetitionsParamsFormatOther          LeaguesCompetitionsParamsFormat = "other"
	LeaguesCompetitionsParamsFormatPasstime       LeaguesCompetitionsParamsFormat = "passtime"
	LeaguesCompetitionsParamsFormatProlander      LeaguesCompetitionsParamsFormat = "prolander"
	LeaguesCompetitionsParamsFormatReadysteadypan LeaguesCompetitionsParamsFormat = "readysteadypan"
	LeaguesCompetitionsParamsFormatUltiduo        LeaguesCompetitionsParamsFormat = "ultiduo"
)

// Defines values for LeaguesCompetitionsParamsType.
const (
	LeaguesCompetitionsParamsTypeCup    LeaguesCompetitionsParamsType = "cup"
	LeaguesCompetitionsParamsTypeOther  LeaguesCompetitionsParamsType = "other"
	LeaguesCompetitionsParamsTypeSeason LeaguesCompetitionsParamsType = "season"
)

// Defines values for LeaguesHistoryParamsLeague.
const (
	LeaguesHistoryParamsLeagueEtf2l      LeaguesHistoryParamsLeague = "etf2l"
	LeaguesHistoryParamsLeagueMgetf      LeaguesHistoryParamsLeague = "mgetf"
	LeaguesHistoryParamsLeagueOzfortress LeaguesHistoryParamsLeague = "ozfortress"
	LeaguesHistoryParamsLeagueRgl        LeaguesHistoryParamsLeague = "rgl"
	LeaguesHistoryParamsLeagueUgc        LeaguesHistoryParamsLeague = "ugc"
)

// Defines values for LeaguesHistoryParamsType.
const (
	LeaguesHistoryParamsTypeCup    LeaguesHistoryParamsType = "cup"
	LeaguesHistoryParamsTypeOther  LeaguesHistoryParamsType = "other"
	LeaguesHistoryParamsTypeSeason LeaguesHistoryParamsType = "season"
)

// Defines values for LeaguesHistoryParamsFormat.
const (
	Bball          LeaguesHistoryParamsFormat = "bball"
	Highlander     LeaguesHistoryParamsFormat = "highlander"
	N1v1           LeaguesHistoryParamsFormat = "1v1"
	N4v4           LeaguesHistoryParamsFormat = "4v4"
	N6v6           LeaguesHistoryParamsFormat = "6v6"
	Nr6v6          LeaguesHistoryParamsFormat = "nr6v6"
	Other          LeaguesHistoryParamsFormat = "other"
	Passtime       LeaguesHistoryParamsFormat = "passtime"
	Prolander      LeaguesHistoryParamsFormat = "prolander"
	Readysteadypan LeaguesHistoryParamsFormat = "readysteadypan"
	Ultiduo        LeaguesHistoryParamsFormat = "ultiduo"
)

// Defines values for LeaguesTeamMembersParamsLeague.
const (
	LeaguesTeamMembersParamsLeagueEtf2l      LeaguesTeamMembersParamsLeague = "etf2l"
	LeaguesTeamMembersParamsLeagueMgetf      LeaguesTeamMembersParamsLeague = "mgetf"
	LeaguesTeamMembersParamsLeagueOzfortress LeaguesTeamMembersParamsLeague = "ozfortress"
	LeaguesTeamMembersParamsLeagueRgl        LeaguesTeamMembersParamsLeague = "rgl"
	LeaguesTeamMembersParamsLeagueUgc        LeaguesTeamMembersParamsLeague = "ugc"
)

// Defines values for LeaguesTeamsParamsLeague.
const (
	LeaguesTeamsParamsLeagueEtf2l      LeaguesTeamsParamsLeague = "etf2l"
	LeaguesTeamsParamsLeagueMgetf      LeaguesTeamsParamsLeague = "mgetf"
	LeaguesTeamsParamsLeagueOzfortress LeaguesTeamsParamsLeague = "ozfortress"
	LeaguesTeamsParamsLeagueRgl        LeaguesTeamsParamsLeague = "rgl"
	LeaguesTeamsParamsLeagueUgc        LeaguesTeamsParamsLeague = "ugc"
)

// BDFileInfo defines model for BDFileInfo.
type BDFileInfo struct {
	// Authors A list of authors of the list
	Authors []string `json:"authors"`

	// Description Description of the list
	Description string `json:"description"`

	// Title Long form name of the list
	Title string `json:"title"`

	// UpdateUrl URL where an update to date copy can be fetched
	UpdateUrl string `json:"update_url"`
}

// BDLastSeen defines model for BDLastSeen.
type BDLastSeen struct {
	// PlayerName Name of the player when last seen
	PlayerName string `json:"player_name,omitempty"`

	// Time Time the player was last seen. Unix timestamp format.
	Time int64 `json:"time,omitempty"`
}

// BDPlayer defines model for BDPlayer.
type BDPlayer struct {
	// Attributes A list of attributes associated with the player
	Attributes []string   `json:"attributes"`
	LastSeen   BDLastSeen `json:"last_seen,omitempty"`

	// Proof Some sort of proof. Please note this is easily manipulatable.
	Proof []string `json:"proof"`

	// Steamid SteamID of the player
	Steamid interface{} `json:"steamid"`
}

// BDSchema defines model for BDSchema.
type BDSchema struct {
	// Schema Location of the schema describing the response
	Schema   string     `json:"$schema"`
	FileInfo BDFileInfo `json:"file_info"`

	// Players List of player entries
	Players []BDPlayer `json:"players"`
}

// BDSearchResult defines model for BDSearchResult.
type BDSearchResult struct {
	// ListName Unique name of the bot detector list
	ListName string   `json:"list_name"`
	Match    BDPlayer `json:"match"`
}

// Ban defines model for Ban.
type Ban struct {
	// CreatedOn When the ban was created
	CreatedOn time.Time `json:"created_on"`

	// ExpiresOn When the ban expires. Null generally means permanent.
	ExpiresOn time.Time `json:"expires_on"`

	// Name Name of the user
	Name string `json:"name"`

	// Permanent Whether the ban is permanent
	Permanent bool `json:"permanent"`

	// Reason Reason of the ban
	Reason string `json:"reason"`

	// SiteName Unique shorthand name of the site
	SiteName string `json:"site_name"`

	// SteamId Steam ID of the banned player
	SteamId string `json:"steam_id"`

	// UnbanReason Reason for the unban
	UnbanReason string `json:"unban_reason"`

	// Unbanned Is the player unbanned
	Unbanned bool `json:"unbanned"`
}

// Duration defines model for Duration.
type Duration = map[string]interface{}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Location Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
	Location string `json:"location,omitempty"`

	// Message Error message text
	Message string `json:"message,omitempty"`

	// Value The value at the given location
	Value interface{} `json:"value,omitempty"`
}

// ErrorModel defines model for ErrorModel.
type ErrorModel struct {
	// Schema A URL to the JSON Schema for this object.
	Schema string `json:"$schema,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail,omitempty"`

	// Errors Optional list of individual error details
	Errors []ErrorDetail `json:"errors"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance string `json:"instance,omitempty"`

	// Status HTTP status code
	Status int64 `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title string `json:"title,omitempty"`

	// Type A URI reference to human-readable documentation for the error.
	Type string `json:"type,omitempty"`
}

// Float32 defines model for Float32.
type Float32 struct {
	Value float32 `json:"Value"`
}

// LeaguePlayerTeamHistory defines model for LeaguePlayerTeamHistory.
type LeaguePlayerTeamHistory struct {
	// Alias Short team name alias, if available
	Alias string `json:"alias"`

	// DivisionName Name of the division/ranking
	DivisionName string `json:"division_name"`

	// Format Game format
	Format string `json:"format"`

	// JoinedTeam When they joined the team
	JoinedTeam time.Time `json:"joined_team"`

	// Leader Leader for the team
	Leader bool `json:"leader"`

	// League League name
	League string `json:"league"`

	// LeagueId The user id of the user on the parent site
	LeagueId int64 `json:"league_id,omitempty"`

	// LeftTeam When they left the team
	LeftTeam time.Time `json:"left_team"`

	// Rank End of season rank
	Rank int64 `json:"rank"`

	// Region Region
	Region string `json:"region"`

	// SeasonName Season/Event name
	SeasonName string `json:"season_name"`

	// SteamId 64bit steam ID as a string
	SteamId string `json:"steam_id"`

	// Tag Short team name tag, if available
	Tag string `json:"tag"`

	// TeamName Name of the team
	TeamName string `json:"team_name"`

	// Type Tournament type
	Type string `json:"type"`
}

// LeagueResponse defines model for LeagueResponse.
type LeagueResponse struct {
	// Format The game format played
	Format LeagueResponseFormat `json:"format"`

	// League The league the competition belongs to
	League string `json:"league"`

	// LeagueId The unique ID of the competition on the source site
	LeagueId int64 `json:"league_id"`

	// Name Name of the competition
	Name string `json:"name"`

	// Region The geographical region, if available
	Region string `json:"region"`

	// Type The type of competition
	Type LeagueResponseType `json:"type"`
}

// LeagueResponseFormat The game format played
type LeagueResponseFormat string

// LeagueResponseType The type of competition
type LeagueResponseType string

// LeagueTeamMemberResponse defines model for LeagueTeamMemberResponse.
type LeagueTeamMemberResponse struct {
	Joined   time.Time `json:"joined"`
	Leader   bool      `json:"leader"`
	LeagueId int64     `json:"league_id"`
	Left     time.Time `json:"left"`
	Name     string    `json:"name"`
	SteamId  string    `json:"steam_id"`
}

// LeagueTeamResponse defines model for LeagueTeamResponse.
type LeagueTeamResponse struct {
	// DivisionName Division of the team
	DivisionName string `json:"division_name"`

	// League The league the team belongs to
	League string `json:"league"`

	// LeagueId The unique ID of the team on the source site
	LeagueId int64 `json:"league_id"`

	// Name Name of the team
	Name string `json:"name"`

	// Rank Final team ranking, if available
	Rank int64 `json:"rank"`

	// Tag Short team name tag, if available
	Tag string `json:"tag"`

	// TeamId UUIDv4
	TeamId string `json:"team_id"`
}

// LogsTFChat defines model for LogsTFChat.
type LogsTFChat struct {
	// CreatedOn The date of the match, not the message specifically
	CreatedOn time.Time `json:"created_on"`

	// LogId Parent Logs.TF match ID
	LogId int64 `json:"log_id"`

	// Message Message sent
	Message string `json:"message"`

	// Name Name of the player at the time
	Name    string `json:"name"`
	SteamId string `json:"steam_id"`
}

// LogsTFClassCountMap defines model for LogsTFClassCountMap.
type LogsTFClassCountMap struct {
	Demoman      int64 `json:"demoman"`
	Engineer     int64 `json:"engineer"`
	Heavyweapons int64 `json:"heavyweapons"`
	Medic        int64 `json:"medic"`
	Pyro         int64 `json:"pyro"`
	Scout        int64 `json:"scout"`
	Sniper       int64 `json:"sniper"`
	Soldier      int64 `json:"soldier"`
	Spy          int64 `json:"spy"`
}

// LogsTFKillStreak defines model for LogsTFKillStreak.
type LogsTFKillStreak struct {
	Steamid string `json:"steamid"`
	Streak  int64  `json:"streak"`
	Time    int64  `json:"time"`
}

// LogsTFMatch defines model for LogsTFMatch.
type LogsTFMatch struct {
	// Schema A URL to the JSON Schema for this object.
	Schema string `json:"$schema,omitempty"`

	// Chat A log of the chat messages
	Chat []LogsTFChat `json:"chat"`

	// CreatedOn When the match occurred
	CreatedOn time.Time `json:"created_on"`
	Duration  Duration  `json:"duration"`

	// Killstreaks Any killstreaks recorded
	Killstreaks []LogsTFKillStreak `json:"killstreaks"`

	// LogId The log id as provided by logs.tf
	LogId int64 `json:"log_id"`

	// Map Map played
	Map string `json:"map"`

	// Medics Summary of medic stats
	Medics []LogsTFMedicOverall `json:"medics"`

	// Players Summary of player stats
	Players []LogsTFPlayerAlt `json:"players"`

	// Rounds Details about each round. May not be present in old logs
	Rounds []LogsTFRound `json:"rounds"`

	// ScoreBlu Final score for BLU team.
	ScoreBlu int64 `json:"score_blu"`

	// ScoreRed Final score for RED team.
	ScoreRed int64       `json:"score_red"`
	Teams    LogsTFTeams `json:"teams"`

	// Title Name of the match
	Title string `json:"title"`

	// Version Version of the match
	Version LogsTFMatchVersion `json:"version"`
}

// LogsTFMatchVersion Version of the match
type LogsTFMatchVersion int64

// LogsTFMatchInfo defines model for LogsTFMatchInfo.
type LogsTFMatchInfo struct {
	// CreatedOn When the match occurred
	CreatedOn time.Time `json:"created_on"`
	Duration  Duration  `json:"duration"`

	// LogId The log id as provided by logs.tf
	LogId int64 `json:"log_id"`

	// Map Map played
	Map string `json:"map"`

	// ScoreBlu Final score for BLU team.
	ScoreBlu int64 `json:"score_blu"`

	// ScoreRed Final score for RED team.
	ScoreRed int64 `json:"score_red"`

	// Title Name of the match
	Title string `json:"title"`

	// Version Version of the match
	Version LogsTFMatchInfoVersion `json:"version"`
}

// LogsTFMatchInfoVersion Version of the match
type LogsTFMatchInfoVersion int64

// LogsTFMedicOverall defines model for LogsTFMedicOverall.
type LogsTFMedicOverall struct {
	AvgTimeBeforeHealing float64          `json:"avg_time_before_healing"`
	AvgTimeBuild         Duration         `json:"avg_time_build"`
	AvgTimeUse           Duration         `json:"avg_time_use"`
	AvgUberLen           Duration         `json:"avg_uber_len"`
	BiggestAdvLost       Duration         `json:"biggest_adv_lost"`
	ChargesKritz         int64            `json:"charges_kritz"`
	ChargesMedigun       int64            `json:"charges_medigun"`
	ChargesQuickfix      int64            `json:"charges_quickfix"`
	ChargesVacc          int64            `json:"charges_vacc"`
	DeathAfterCharge     int64            `json:"death_after_charge"`
	Drops                int64            `json:"drops"`
	Healing              int64            `json:"healing"`
	HealingPerMin        float64          `json:"healing_per_min"`
	Healspread           map[string]int64 `json:"healspread"`
	MajorAdvLost         int64            `json:"major_adv_lost"`
	NearFullDeath        int64            `json:"near_full_death"`
	SteamId              string           `json:"steam_id"`
}

// LogsTFPlayerAlt defines model for LogsTFPlayerAlt.
type LogsTFPlayerAlt struct {
	Airshots           int64                    `json:"airshots"`
	Assists            int64                    `json:"assists"`
	Backstabs          int64                    `json:"backstabs"`
	Caps               int64                    `json:"caps"`
	ClassAssists       LogsTFClassCountMap      `json:"class_assists"`
	ClassDeaths        LogsTFClassCountMap      `json:"class_deaths"`
	ClassKills         LogsTFClassCountMap      `json:"class_kills"`
	Classes            []LogsTFPlayerClassStats `json:"classes"`
	Damage             int64                    `json:"damage"`
	DamageTaken        int64                    `json:"damage_taken"`
	Deaths             int64                    `json:"deaths"`
	Dpm                int64                    `json:"dpm"`
	Dtm                float64                  `json:"dtm"`
	Headshots          int64                    `json:"headshots"`
	HealingTaken       int64                    `json:"healing_taken"`
	HealthPacks        int64                    `json:"health_packs"`
	HealthPacksHealing int64                    `json:"health_packs_healing"`
	Kad                float64                  `json:"kad"`
	Kd                 float64                  `json:"kd"`
	Kills              int64                    `json:"kills"`
	Name               string                   `json:"name"`
	SteamId            string                   `json:"steam_id"`
	Team               string                   `json:"team"`
}

// LogsTFPlayerClassStats defines model for LogsTFPlayerClassStats.
type LogsTFPlayerClassStats struct {
	Assists int64                     `json:"assists"`
	Class   string                    `json:"class"`
	Damage  int64                     `json:"damage"`
	Deaths  int64                     `json:"deaths"`
	Kills   int64                     `json:"kills"`
	Played  Duration                  `json:"played"`
	Weapons []LogsTFPlayerClassWeapon `json:"weapons"`
}

// LogsTFPlayerClassWeapon defines model for LogsTFPlayerClassWeapon.
type LogsTFPlayerClassWeapon struct {
	SteamID  string `json:"SteamID"`
	Accuracy int64  `json:"accuracy"`
	Damage   int64  `json:"damage"`
	Hits     int64  `json:"hits"`
	Kills    int64  `json:"kills"`
	Shots    int64  `json:"shots"`
	Weapon   string `json:"weapon"`
}

// LogsTFPlayerSummary defines model for LogsTFPlayerSummary.
type LogsTFPlayerSummary struct {
	// Schema A URL to the JSON Schema for this object.
	Schema          string  `json:"$schema,omitempty"`
	AirshotsAvg     Float32 `json:"airshots_avg"`
	AirshotsSum     int64   `json:"airshots_sum"`
	AssistsAvg      Float32 `json:"assists_avg"`
	AssistsSum      int64   `json:"assists_sum"`
	BackstabsAvg    Float32 `json:"backstabs_avg"`
	BackstabsSum    int64   `json:"backstabs_sum"`
	CapsAvg         Float32 `json:"caps_avg"`
	CapsSum         int64   `json:"caps_sum"`
	DamageAvg       Float32 `json:"damage_avg"`
	DamageSum       int64   `json:"damage_sum"`
	DamageTakenAvg  Float32 `json:"damage_taken_avg"`
	DamageTakenSum  int64   `json:"damage_taken_sum"`
	DeathsAvg       Float32 `json:"deaths_avg"`
	DeathsSum       int64   `json:"deaths_sum"`
	DpmAvg          Float32 `json:"dpm_avg"`
	DtmAvg          Float32 `json:"dtm_avg"`
	HeadshotsAvg    Float32 `json:"headshots_avg"`
	HeadshotsSum    int64   `json:"headshots_sum"`
	HealingTakenAvg Float32 `json:"healing_taken_avg"`
	HealingTakenSum int64   `json:"healing_taken_sum"`
	HealthPacksAvg  Float32 `json:"health_packs_avg"`
	HealthPacksSum  int64   `json:"health_packs_sum"`
	KadAvg          Float32 `json:"kad_avg"`
	KdAvg           Float32 `json:"kd_avg"`
	KillsAvg        Float32 `json:"kills_avg"`
	KillsSum        int64   `json:"kills_sum"`
	Logs            int64   `json:"logs"`
}

// LogsTFRound defines model for LogsTFRound.
type LogsTFRound struct {
	// DamageBlu BLU damage count
	DamageBlu int64 `json:"damage_blu"`

	// DamageRed RED damage count
	DamageRed int64 `json:"damage_red"`

	// KillsBlu BLU kill count
	KillsBlu int64 `json:"kills_blu"`

	// KillsRed RED kill count
	KillsRed int64    `json:"kills_red"`
	Length   Duration `json:"length"`

	// MidFight Who won the midfight
	MidFight string `json:"mid_fight,omitempty"`

	// Players Stats for the players during the round
	Players []LogsTFRoundPlayerAlt `json:"players"`

	// Round Round number
	Round int64 `json:"round"`

	// ScoreBlu BLU score at end of round
	ScoreBlu int64 `json:"score_blu"`

	// ScoreRed RED score at end of round
	ScoreRed int64 `json:"score_red"`

	// UbersBlu BLU uber count
	UbersBlu int64 `json:"ubers_blu"`

	// UbersRed RED uber count
	UbersRed int64 `json:"ubers_red"`
}

// LogsTFRoundPlayerAlt defines model for LogsTFRoundPlayerAlt.
type LogsTFRoundPlayerAlt struct {
	// Dmg Total damage
	Dmg int64 `json:"dmg"`

	// Kills Total kills
	Kills int64 `json:"kills"`

	// SteamId Player steam id
	SteamId string `json:"steam_id"`
}

// LogsTFTeamOverall defines model for LogsTFTeamOverall.
type LogsTFTeamOverall struct {
	Caps      int64 `json:"caps"`
	Charges   int64 `json:"charges"`
	Damage    int64 `json:"damage"`
	Deaths    int64 `json:"deaths"`
	Drops     int64 `json:"drops"`
	FirstCaps int64 `json:"first_caps"`
	Kills     int64 `json:"kills"`
	Score     int64 `json:"score"`
}

// LogsTFTeams defines model for LogsTFTeams.
type LogsTFTeams struct {
	Blu LogsTFTeamOverall `json:"blu"`
	Red LogsTFTeamOverall `json:"red"`
}

// MetaProfile defines model for MetaProfile.
type MetaProfile struct {
	// AvatarHash The avatar hash of the user
	AvatarHash string `json:"avatar_hash"`

	// Bans Number of 3rd party bans. Includes leagues and pubs.
	Bans []Ban `json:"bans"`

	// CommunityBanned Is the user steam community banned
	CommunityBanned bool `json:"community_banned"`

	// CommunityVisibilityState Represents whether the profile is visible or not and why.
	CommunityVisibilityState MetaProfileCommunityVisibilityState `json:"community_visibility_state"`

	// CompetitiveTeams Competitive league team history
	CompetitiveTeams []LeaguePlayerTeamHistory `json:"competitive_teams"`
	DaysSinceLastBan int64                     `json:"days_since_last_ban"`

	// EconomyBan Is the user trade banned
	EconomyBan string `json:"economy_ban"`

	// Friends Last known list of friends
	Friends []SteamFriend `json:"friends"`

	// LogsCount Number of logs the user has on logs.tf
	LogsCount int64 `json:"logs_count"`

	// NumberOfGameBans How many game bans the user has
	NumberOfGameBans int64 `json:"number_of_game_bans"`

	// NumberOfVacBans How many vac bans does the user have
	NumberOfVacBans int64 `json:"number_of_vac_bans"`

	// PersonaName The current alias of the user
	PersonaName string `json:"persona_name"`

	// ProfileState Has the profile been set up
	ProfileState MetaProfileProfileState `json:"profile_state"`

	// RealName Real name of the user
	RealName string `json:"real_name"`

	// SteamId 64bit Steam ID
	SteamId string `json:"steam_id"`

	// TimeCreated When the account was created. This may be estimated if not available.
	TimeCreated int64 `json:"time_created"`
}

// MetaProfileCommunityVisibilityState Represents whether the profile is visible or not and why.
type MetaProfileCommunityVisibilityState int64

// MetaProfileProfileState Has the profile been set up
type MetaProfileProfileState int64

// PlayerTeamHistoryResponse defines model for PlayerTeamHistoryResponse.
type PlayerTeamHistoryResponse struct {
	// Alias Player alias on team
	Alias string `json:"alias"`

	// DivisionName Division name
	DivisionName string `json:"division_name"`

	// Format The format of games.
	Format string `json:"format"`

	// JoinedTeam Date of joining the team
	JoinedTeam time.Time `json:"joined_team"`

	// Leader Was a team leader
	Leader bool `json:"leader"`

	// League Unique shorthand name of the league
	League string `json:"league"`

	// LeftTeam Date of leaving the team
	LeftTeam time.Time `json:"left_team"`

	// Rank Final ranking
	Rank int64 `json:"rank"`

	// Region The geographical region
	Region string `json:"region"`

	// SeasonName Season/Cup name
	SeasonName string `json:"season_name"`
	SteamId    string `json:"steam_id"`

	// Tag Short tag for the team
	Tag string `json:"tag"`

	// TeamName Name of the team
	TeamName string `json:"team_name"`

	// Type Type of the tournament
	Type PlayerTeamHistoryResponseType `json:"type"`
}

// PlayerTeamHistoryResponseType Type of the tournament
type PlayerTeamHistoryResponseType string

// SiteInfo defines model for SiteInfo.
type SiteInfo struct {
	// Name Unique name/key of the site
	Name string `json:"name"`

	// Title Longer decorative title of the site
	Title string `json:"title"`

	// Type Type of the site
	Type string `json:"type"`

	// Url URL to the site
	Url string `json:"url"`
}

// SteamFriend defines model for SteamFriend.
type SteamFriend struct {
	FriendSince  time.Time `json:"friend_since"`
	Relationship string    `json:"relationship"`
	RemovedOn    time.Time `json:"removed_on"`
	SteamId      string    `json:"steam_id"`
}

// BansSearchParams defines parameters for BansSearch.
type BansSearchParams struct {
	SiteName     string `form:"site_name,omitempty" json:"site_name,omitempty"`
	HideUnbanned bool   `form:"hide_unbanned,omitempty" json:"hide_unbanned,omitempty"`

	// Steamids Comma separated list of Steam IDs in any standard format
	Steamids string `form:"steamids" json:"steamids"`
}

// BdListParams defines parameters for BdList.
type BdListParams struct {
	Site string `form:"site,omitempty" json:"site,omitempty"`
}

// BdSearchParams defines parameters for BdSearch.
type BdSearchParams struct {
	// Steamids Comma separated list of Steam IDs in any standard format
	Steamids string   `form:"steamids" json:"steamids"`
	Attrs    []string `form:"attrs,omitempty" json:"attrs,omitempty"`
}

// LeaguesCompetitionsParams defines parameters for LeaguesCompetitions.
type LeaguesCompetitionsParams struct {
	League LeaguesCompetitionsParamsLeague `form:"league,omitempty" json:"league,omitempty"`
	Format LeaguesCompetitionsParamsFormat `form:"format,omitempty" json:"format,omitempty"`
	Type   LeaguesCompetitionsParamsType   `form:"type,omitempty" json:"type,omitempty"`
}

// LeaguesCompetitionsParamsLeague defines parameters for LeaguesCompetitions.
type LeaguesCompetitionsParamsLeague string

// LeaguesCompetitionsParamsFormat defines parameters for LeaguesCompetitions.
type LeaguesCompetitionsParamsFormat string

// LeaguesCompetitionsParamsType defines parameters for LeaguesCompetitions.
type LeaguesCompetitionsParamsType string

// LeaguesHistoryParams defines parameters for LeaguesHistory.
type LeaguesHistoryParams struct {
	// Steamids Comma separated list of Steam IDs in any standard format
	Steamids string `form:"steamids" json:"steamids"`

	// League Name of the league
	League LeaguesHistoryParamsLeague `form:"league,omitempty" json:"league,omitempty"`

	// Type Type of event ran
	Type LeaguesHistoryParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Format Game format
	Format LeaguesHistoryParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// LeaguesHistoryParamsLeague defines parameters for LeaguesHistory.
type LeaguesHistoryParamsLeague string

// LeaguesHistoryParamsType defines parameters for LeaguesHistory.
type LeaguesHistoryParamsType string

// LeaguesHistoryParamsFormat defines parameters for LeaguesHistory.
type LeaguesHistoryParamsFormat string

// LeaguesTeamMembersParams defines parameters for LeaguesTeamMembers.
type LeaguesTeamMembersParams struct {
	// League League to query
	League LeaguesTeamMembersParamsLeague `form:"league" json:"league"`

	// LeagueId Unique Team ID on the parent site
	LeagueId int64 `form:"league_id" json:"league_id"`
}

// LeaguesTeamMembersParamsLeague defines parameters for LeaguesTeamMembers.
type LeaguesTeamMembersParamsLeague string

// LeaguesTeamsParams defines parameters for LeaguesTeams.
type LeaguesTeamsParams struct {
	// League Name of the league
	League LeaguesTeamsParamsLeague `form:"league,omitempty" json:"league,omitempty"`

	// LeagueId The unique, to the provided league, id of the team
	LeagueId int64 `form:"league_id,omitempty" json:"league_id,omitempty"`

	// Name Query the name
	Name string `form:"name,omitempty" json:"name,omitempty"`
}

// LeaguesTeamsParamsLeague defines parameters for LeaguesTeams.
type LeaguesTeamsParamsLeague string

// LogstfChatQueryParams defines parameters for LogstfChatQuery.
type LogstfChatQueryParams struct {
	// Steamid Steam ID in any standard format
	Steamid string `form:"steamid" json:"steamid"`
	Query   string `form:"query,omitempty" json:"query,omitempty"`
}

// LogstfMatchListParams defines parameters for LogstfMatchList.
type LogstfMatchListParams struct {
	// Steamid Steam ID in any standard format
	Steamid string `form:"steamid" json:"steamid"`
}

// LogstfPlayerSummaryParams defines parameters for LogstfPlayerSummary.
type LogstfPlayerSummaryParams struct {
	// Steamid Steam ID in any standard format
	Steamid string `form:"steamid" json:"steamid"`
}

// MetaProfileParams defines parameters for MetaProfile.
type MetaProfileParams struct {
	// Steamids Comma separated list of Steam IDs in any standard format
	Steamids string `form:"steamids" json:"steamids"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BansSearch request
	BansSearch(ctx context.Context, params *BansSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BdList request
	BdList(ctx context.Context, params *BdListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BdSearch request
	BdSearch(ctx context.Context, params *BdSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaguesCompetitions request
	LeaguesCompetitions(ctx context.Context, params *LeaguesCompetitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaguesHistory request
	LeaguesHistory(ctx context.Context, params *LeaguesHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaguesTeamMembers request
	LeaguesTeamMembers(ctx context.Context, params *LeaguesTeamMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaguesTeams request
	LeaguesTeams(ctx context.Context, params *LeaguesTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogstfChatQuery request
	LogstfChatQuery(ctx context.Context, params *LogstfChatQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogstfLog request
	LogstfLog(ctx context.Context, logid int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogstfMatchList request
	LogstfMatchList(ctx context.Context, params *LogstfMatchListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogstfPlayerSummary request
	LogstfPlayerSummary(ctx context.Context, params *LogstfPlayerSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetaProfile request
	MetaProfile(ctx context.Context, params *MetaProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetaSites request
	MetaSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BansSearch(ctx context.Context, params *BansSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBansSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BdList(ctx context.Context, params *BdListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBdListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BdSearch(ctx context.Context, params *BdSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBdSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaguesCompetitions(ctx context.Context, params *LeaguesCompetitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaguesCompetitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaguesHistory(ctx context.Context, params *LeaguesHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaguesHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaguesTeamMembers(ctx context.Context, params *LeaguesTeamMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaguesTeamMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaguesTeams(ctx context.Context, params *LeaguesTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaguesTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogstfChatQuery(ctx context.Context, params *LogstfChatQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogstfChatQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogstfLog(ctx context.Context, logid int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogstfLogRequest(c.Server, logid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogstfMatchList(ctx context.Context, params *LogstfMatchListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogstfMatchListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogstfPlayerSummary(ctx context.Context, params *LogstfPlayerSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogstfPlayerSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetaProfile(ctx context.Context, params *MetaProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetaProfileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetaSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetaSitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBansSearchRequest generates requests for BansSearch
func NewBansSearchRequest(server string, params *BansSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/bans/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "site_name", runtime.ParamLocationQuery, params.SiteName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "hide_unbanned", runtime.ParamLocationQuery, params.HideUnbanned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "steamids", runtime.ParamLocationQuery, params.Steamids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBdListRequest generates requests for BdList
func NewBdListRequest(server string, params *BdListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/bd/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "site", runtime.ParamLocationQuery, params.Site); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBdSearchRequest generates requests for BdSearch
func NewBdSearchRequest(server string, params *BdSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/bd/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "steamids", runtime.ParamLocationQuery, params.Steamids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "attrs", runtime.ParamLocationQuery, params.Attrs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaguesCompetitionsRequest generates requests for LeaguesCompetitions
func NewLeaguesCompetitionsRequest(server string, params *LeaguesCompetitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/leagues/competitions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "league", runtime.ParamLocationQuery, params.League); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaguesHistoryRequest generates requests for LeaguesHistory
func NewLeaguesHistoryRequest(server string, params *LeaguesHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/leagues/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "steamids", runtime.ParamLocationQuery, params.Steamids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "league", runtime.ParamLocationQuery, params.League); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaguesTeamMembersRequest generates requests for LeaguesTeamMembers
func NewLeaguesTeamMembersRequest(server string, params *LeaguesTeamMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/leagues/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "league", runtime.ParamLocationQuery, params.League); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "league_id", runtime.ParamLocationQuery, params.LeagueId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaguesTeamsRequest generates requests for LeaguesTeams
func NewLeaguesTeamsRequest(server string, params *LeaguesTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/leagues/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "league", runtime.ParamLocationQuery, params.League); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "league_id", runtime.ParamLocationQuery, params.LeagueId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogstfChatQueryRequest generates requests for LogstfChatQuery
func NewLogstfChatQueryRequest(server string, params *LogstfChatQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/logstf/chat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "steamid", runtime.ParamLocationQuery, params.Steamid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogstfLogRequest generates requests for LogstfLog
func NewLogstfLogRequest(server string, logid int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "logid", runtime.ParamLocationPath, logid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/logstf/log/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogstfMatchListRequest generates requests for LogstfMatchList
func NewLogstfMatchListRequest(server string, params *LogstfMatchListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/logstf/matches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "steamid", runtime.ParamLocationQuery, params.Steamid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogstfPlayerSummaryRequest generates requests for LogstfPlayerSummary
func NewLogstfPlayerSummaryRequest(server string, params *LogstfPlayerSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/logstf/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "steamid", runtime.ParamLocationQuery, params.Steamid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetaProfileRequest generates requests for MetaProfile
func NewMetaProfileRequest(server string, params *MetaProfileParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/meta/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "steamids", runtime.ParamLocationQuery, params.Steamids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetaSitesRequest generates requests for MetaSites
func NewMetaSitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/meta/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BansSearchWithResponse request
	BansSearchWithResponse(ctx context.Context, params *BansSearchParams, reqEditors ...RequestEditorFn) (*BansSearchResponse, error)

	// BdListWithResponse request
	BdListWithResponse(ctx context.Context, params *BdListParams, reqEditors ...RequestEditorFn) (*BdListResponse, error)

	// BdSearchWithResponse request
	BdSearchWithResponse(ctx context.Context, params *BdSearchParams, reqEditors ...RequestEditorFn) (*BdSearchResponse, error)

	// LeaguesCompetitionsWithResponse request
	LeaguesCompetitionsWithResponse(ctx context.Context, params *LeaguesCompetitionsParams, reqEditors ...RequestEditorFn) (*LeaguesCompetitionsResponse, error)

	// LeaguesHistoryWithResponse request
	LeaguesHistoryWithResponse(ctx context.Context, params *LeaguesHistoryParams, reqEditors ...RequestEditorFn) (*LeaguesHistoryResponse, error)

	// LeaguesTeamMembersWithResponse request
	LeaguesTeamMembersWithResponse(ctx context.Context, params *LeaguesTeamMembersParams, reqEditors ...RequestEditorFn) (*LeaguesTeamMembersResponse, error)

	// LeaguesTeamsWithResponse request
	LeaguesTeamsWithResponse(ctx context.Context, params *LeaguesTeamsParams, reqEditors ...RequestEditorFn) (*LeaguesTeamsResponse, error)

	// LogstfChatQueryWithResponse request
	LogstfChatQueryWithResponse(ctx context.Context, params *LogstfChatQueryParams, reqEditors ...RequestEditorFn) (*LogstfChatQueryResponse, error)

	// LogstfLogWithResponse request
	LogstfLogWithResponse(ctx context.Context, logid int64, reqEditors ...RequestEditorFn) (*LogstfLogResponse, error)

	// LogstfMatchListWithResponse request
	LogstfMatchListWithResponse(ctx context.Context, params *LogstfMatchListParams, reqEditors ...RequestEditorFn) (*LogstfMatchListResponse, error)

	// LogstfPlayerSummaryWithResponse request
	LogstfPlayerSummaryWithResponse(ctx context.Context, params *LogstfPlayerSummaryParams, reqEditors ...RequestEditorFn) (*LogstfPlayerSummaryResponse, error)

	// MetaProfileWithResponse request
	MetaProfileWithResponse(ctx context.Context, params *MetaProfileParams, reqEditors ...RequestEditorFn) (*MetaProfileResponse, error)

	// MetaSitesWithResponse request
	MetaSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetaSitesResponse, error)
}

type BansSearchResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Ban
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r BansSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BansSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BdListResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *BDSchema
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r BdListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BdListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BdSearchResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]BDSearchResult
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r BdSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BdSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaguesCompetitionsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]LeagueResponse
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LeaguesCompetitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaguesCompetitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaguesHistoryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]PlayerTeamHistoryResponse
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LeaguesHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaguesHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaguesTeamMembersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]LeagueTeamMemberResponse
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LeaguesTeamMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaguesTeamMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaguesTeamsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]LeagueTeamResponse
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LeaguesTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaguesTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogstfChatQueryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]LogsTFChat
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LogstfChatQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogstfChatQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogstfLogResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *LogsTFMatch
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LogstfLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogstfLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogstfMatchListResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]LogsTFMatchInfo
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LogstfMatchListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogstfMatchListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogstfPlayerSummaryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *LogsTFPlayerSummary
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LogstfPlayerSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogstfPlayerSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetaProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]MetaProfile
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r MetaProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetaProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetaSitesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]SiteInfo
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r MetaSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetaSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BansSearchWithResponse request returning *BansSearchResponse
func (c *ClientWithResponses) BansSearchWithResponse(ctx context.Context, params *BansSearchParams, reqEditors ...RequestEditorFn) (*BansSearchResponse, error) {
	rsp, err := c.BansSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBansSearchResponse(rsp)
}

// BdListWithResponse request returning *BdListResponse
func (c *ClientWithResponses) BdListWithResponse(ctx context.Context, params *BdListParams, reqEditors ...RequestEditorFn) (*BdListResponse, error) {
	rsp, err := c.BdList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBdListResponse(rsp)
}

// BdSearchWithResponse request returning *BdSearchResponse
func (c *ClientWithResponses) BdSearchWithResponse(ctx context.Context, params *BdSearchParams, reqEditors ...RequestEditorFn) (*BdSearchResponse, error) {
	rsp, err := c.BdSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBdSearchResponse(rsp)
}

// LeaguesCompetitionsWithResponse request returning *LeaguesCompetitionsResponse
func (c *ClientWithResponses) LeaguesCompetitionsWithResponse(ctx context.Context, params *LeaguesCompetitionsParams, reqEditors ...RequestEditorFn) (*LeaguesCompetitionsResponse, error) {
	rsp, err := c.LeaguesCompetitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaguesCompetitionsResponse(rsp)
}

// LeaguesHistoryWithResponse request returning *LeaguesHistoryResponse
func (c *ClientWithResponses) LeaguesHistoryWithResponse(ctx context.Context, params *LeaguesHistoryParams, reqEditors ...RequestEditorFn) (*LeaguesHistoryResponse, error) {
	rsp, err := c.LeaguesHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaguesHistoryResponse(rsp)
}

// LeaguesTeamMembersWithResponse request returning *LeaguesTeamMembersResponse
func (c *ClientWithResponses) LeaguesTeamMembersWithResponse(ctx context.Context, params *LeaguesTeamMembersParams, reqEditors ...RequestEditorFn) (*LeaguesTeamMembersResponse, error) {
	rsp, err := c.LeaguesTeamMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaguesTeamMembersResponse(rsp)
}

// LeaguesTeamsWithResponse request returning *LeaguesTeamsResponse
func (c *ClientWithResponses) LeaguesTeamsWithResponse(ctx context.Context, params *LeaguesTeamsParams, reqEditors ...RequestEditorFn) (*LeaguesTeamsResponse, error) {
	rsp, err := c.LeaguesTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaguesTeamsResponse(rsp)
}

// LogstfChatQueryWithResponse request returning *LogstfChatQueryResponse
func (c *ClientWithResponses) LogstfChatQueryWithResponse(ctx context.Context, params *LogstfChatQueryParams, reqEditors ...RequestEditorFn) (*LogstfChatQueryResponse, error) {
	rsp, err := c.LogstfChatQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogstfChatQueryResponse(rsp)
}

// LogstfLogWithResponse request returning *LogstfLogResponse
func (c *ClientWithResponses) LogstfLogWithResponse(ctx context.Context, logid int64, reqEditors ...RequestEditorFn) (*LogstfLogResponse, error) {
	rsp, err := c.LogstfLog(ctx, logid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogstfLogResponse(rsp)
}

// LogstfMatchListWithResponse request returning *LogstfMatchListResponse
func (c *ClientWithResponses) LogstfMatchListWithResponse(ctx context.Context, params *LogstfMatchListParams, reqEditors ...RequestEditorFn) (*LogstfMatchListResponse, error) {
	rsp, err := c.LogstfMatchList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogstfMatchListResponse(rsp)
}

// LogstfPlayerSummaryWithResponse request returning *LogstfPlayerSummaryResponse
func (c *ClientWithResponses) LogstfPlayerSummaryWithResponse(ctx context.Context, params *LogstfPlayerSummaryParams, reqEditors ...RequestEditorFn) (*LogstfPlayerSummaryResponse, error) {
	rsp, err := c.LogstfPlayerSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogstfPlayerSummaryResponse(rsp)
}

// MetaProfileWithResponse request returning *MetaProfileResponse
func (c *ClientWithResponses) MetaProfileWithResponse(ctx context.Context, params *MetaProfileParams, reqEditors ...RequestEditorFn) (*MetaProfileResponse, error) {
	rsp, err := c.MetaProfile(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetaProfileResponse(rsp)
}

// MetaSitesWithResponse request returning *MetaSitesResponse
func (c *ClientWithResponses) MetaSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetaSitesResponse, error) {
	rsp, err := c.MetaSites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetaSitesResponse(rsp)
}

// ParseBansSearchResponse parses an HTTP response from a BansSearchWithResponse call
func ParseBansSearchResponse(rsp *http.Response) (*BansSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BansSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Ban
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseBdListResponse parses an HTTP response from a BdListWithResponse call
func ParseBdListResponse(rsp *http.Response) (*BdListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BdListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BDSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseBdSearchResponse parses an HTTP response from a BdSearchWithResponse call
func ParseBdSearchResponse(rsp *http.Response) (*BdSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BdSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BDSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLeaguesCompetitionsResponse parses an HTTP response from a LeaguesCompetitionsWithResponse call
func ParseLeaguesCompetitionsResponse(rsp *http.Response) (*LeaguesCompetitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaguesCompetitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LeagueResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLeaguesHistoryResponse parses an HTTP response from a LeaguesHistoryWithResponse call
func ParseLeaguesHistoryResponse(rsp *http.Response) (*LeaguesHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaguesHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PlayerTeamHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLeaguesTeamMembersResponse parses an HTTP response from a LeaguesTeamMembersWithResponse call
func ParseLeaguesTeamMembersResponse(rsp *http.Response) (*LeaguesTeamMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaguesTeamMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LeagueTeamMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLeaguesTeamsResponse parses an HTTP response from a LeaguesTeamsWithResponse call
func ParseLeaguesTeamsResponse(rsp *http.Response) (*LeaguesTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaguesTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LeagueTeamResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLogstfChatQueryResponse parses an HTTP response from a LogstfChatQueryWithResponse call
func ParseLogstfChatQueryResponse(rsp *http.Response) (*LogstfChatQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogstfChatQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LogsTFChat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLogstfLogResponse parses an HTTP response from a LogstfLogWithResponse call
func ParseLogstfLogResponse(rsp *http.Response) (*LogstfLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogstfLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogsTFMatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLogstfMatchListResponse parses an HTTP response from a LogstfMatchListWithResponse call
func ParseLogstfMatchListResponse(rsp *http.Response) (*LogstfMatchListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogstfMatchListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LogsTFMatchInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLogstfPlayerSummaryResponse parses an HTTP response from a LogstfPlayerSummaryWithResponse call
func ParseLogstfPlayerSummaryResponse(rsp *http.Response) (*LogstfPlayerSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogstfPlayerSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogsTFPlayerSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMetaProfileResponse parses an HTTP response from a MetaProfileWithResponse call
func ParseMetaProfileResponse(rsp *http.Response) (*MetaProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetaProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MetaProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMetaSitesResponse parses an HTTP response from a MetaSitesWithResponse call
func ParseMetaSitesResponse(rsp *http.Response) (*MetaSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetaSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SiteInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
